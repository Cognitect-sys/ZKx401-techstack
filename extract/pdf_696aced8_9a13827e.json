{"origin_pdf_path": "https://arxiv.org/pdf/2502.07063", "text_in_pdf": "TABLE III: ZK Framework Attributes   \n\nUsabilityAccessibilityFrameworkLanguage(s)Custom CLicenseExamplesDocumentationGitHub IssuesLast Major Updatezk-SNARKsArkworks [26]RustMIT, Apache-2Dec.2023Gnark [49]GoApache-2Dec.2024Hyrax [2]PythonApache-2OFeb.2018LEGOSnark [3]C++MIT, Apache-2。OOct.2020LibSNARK [4]C++, Java (xJsnark [92])MITJul. 2020Zokrates [64]Zokrates DSLLGPL-3.0Nov.2023Mirage [5]JavaMITOJan. 2021PySNARK [7]PythonCustom (MIT-like) GPL-3May 2023SnarkJS [34]Circom [106]Oct.2024Rapidsnark [8]Circom [106]OGPL-3×ODec.2023Spartan [10]RustOMITJan.2023Aurora (libiop) [118]++MITMay 2021Fractal (libiop) [118]C++OMIT。May 2021Virgo [128]PythonOApache-2OJul. 2021Noir [17]Rust DSLMIT, Apache-2Nov. 2024Dusk-PLONK [13]RustOMPL-2Aug. 2024Halo2 [14]RustMIT, Apache-2Nov.2023MPC-in-the-HeadLimbo [94]Bristol [131]MITOMay 2021Ligero (libiop) [118]++OMITMay 2021VOLE-Based ZKMozzarella [32]RustOMITOMar. 2022Diet Mac'n'Cheese [1]PicoZK [6]MITOSep. 2024Emp-ZK [139]++MITSep.2023zk-STARKsMidenVM [20]Miden AssemblyMITNov. 2023Zilch [133]Java DSLMITOApr. 2022RISC Zero [115]Rust, C++Apache-2Dec.2024  \n\ndevelopment and seems to have an active community around it, making it an accessible option for inexperienced ZKP developers. We recommend this for beginners and experts alike for almost any custom applications. This framework utilizes a readable and robust API that any user can take advantage of and build custom applications with.  \n\narkworks. The arkworks Rust ecosystem [26] is an extensive and modular collection of libraries that can be used for efficient zk-SNARK programming. This ecosystem provides highly efficient implementations of arithmetic over various curves and fields, even allowing curve specific optimizations. The main offering of arkworks is a generic application development framework that supports both experienced and non-experienced zk-SNARK developers. This framework enables high-level zk-SNARK development, as it allows users to implement their circuit as constraints (R1CS), while abstracting out details of SNARKs and curves, using an arkworks library. To venture into lower-level optimizations, arkworks provides libraries for the user to describe their circuit in native code. This allows the users to make several design decisions, such as specifying which proving system, such as Groth16, they would like to use. Alongside this, arkworks also provides libraries implementing low-level finite field, elliptic curve, and polynomial interfaces. In addition to SHA256, ZKP-friendly hashes such as Pedersen [35] and Poseidon [78] hashing are also offered. The arkworks development ecosystem is actively maintained and has an active community. We recommend this framework for users that have a deep knowledge of ZKPs, as one of the main advantages of arkworks, other than it’s fantastic and usable codebase, is the ability to tweak certain parameters to optimize operations for your custom application.  \n\nhyraxZK. Hyrax is a ”doubly-efficient” zk-SNARK scheme, providing a concretely efficient prover and verifier, with low communication cost and no trusted setup [137]. Instead of following a standard underlying zk-SNARK structure, Hyrax is built on top of the Giraffe interactive proof scheme [136]. The authors apply a technique to reduce communication cost and add cryptopgraphic operations to turn the interactive proof into a ZKP. With the addition of optimized cryptographic commitments, the concrete cost of this scheme is significantly reduced and results in an interactive ZKP scheme. Using the Fiat-Shamir transform [90], this scheme is made non-interactive. hyraxZK [2] provides a cleanly-developed Python and $C++$ development environment using Hyrax as the underlying zk-SNARK scheme. The provided framework is well-developed, however there is a lack of documentation that makes it challenging to build custom circuits.  \n\nlibspartan. libspartan [10] is a Rust library that implements the Spartan zk-SNARK proof system [120]. Spartan is a transparent zk-SNARK proof system, meaning that it requires no trusted setup. libspartan utilizes a Rust implemention of group operations on prime-order group Ristretto [11] and elliptic curve Curve25519 [43], which ensures security and speed. By adding a new commitment scheme, alongside a novel cryptographic compiler and a compact encoding of R1CS instances, Spartan is able to achieve the first transparent proof system with sub-linear verification costs and a time-optimal prover, at the cost of memory-heavy computation on the prover side. libspartan is a welldeveloped and maintained framework, however implementing custom functions is not very straightforward based on the provided documentation. Developing a custom ZKP circuit in libspartan requires the user to have the parameters of the R1CS instance, alongside knowledge of how to encode the constraints into R1CS matrices. Depending on the size of the ZKP circuit, this process can be very rigorous and involved, while also requiring a full knowledge of R1CS representations. Zokrates [64] provides a high-level API to build an R1CS for custom ZKP circuits, however a developer then has to manually convert these into a format that is readable by libspartan, which can be time-intensive depending on the number of constraints in the circuit. We only recommend this framework to users that have an in-depth knowledge of ZK constraint systems, however, we do note that this framework’s backend is state-of-the-art and, upon integration with a standard frontend, would be a perfect solution for most ZK applications.  \n\nMirage. Mirage [91] is a universal zk-SNARK scheme and aptly named Java framework [5] implementing such scheme. Mirage’s main contribution is a universal trusted setup, such that trusted setup does not have to be performed everytime the circuit changes, as is done in zk-SNARKs. This saves a great amount of time and computation at the cost of higher proof computation overhead. This work introduces the idea of separated zk-SNARKs, which enables efficient randomized checks in zk-SNARK circuits. This results in simplified verification complexity. Combining this with their novel universal circuit generator that produces circuits linear in the number of additions and multiplications, the Mirage zk-SNARK scheme is introduced. The underlying scheme and circuit generator are implemented in the mirage codebase, which has a Java frontend for circuit generation and a $C++$ backend implementing Mirage on top of libsnark. The core of development is done in mirage’s universal circuit generator, as that is where the ZKP circuits are specified by the user. This codebase provides very readable and diverse examples that highlight the use cases of their high-level Java API. Not only is there a bit of a learning curve to get acquainted with mirage’s syntax, but we also found that the codebase is relatively outdated, meaning that the code no longer compiles.  \n\nLegoSNARK. LegoSNARK [54] is a zk-SNARK scheme and library that focuses on linking SNARK ”gadgets” together to build zk-SNARKs with a modular approach. This library implements the modular zk-SNARKs in the form of commitand-prove zk-SNARKs (CP-SNARKs) [98], which are a class of zk-SNARKs that prove statements about committed values. As previous CP-SNARK schemes are limited due to their reliance on a single commitment scheme, one of the most important contributions of this work is a generic construction that can convert a broad class of zk-SNARKS, such as QAPbased, to CP-SNARKs. The LegoSNARK library [3] provides end-to-end proving and verification using the proposed scheme in a $C++$ package. This work builds upon libsnark, albeit with integration to high-level libsnark frameworks, such as xJsnark. Nevertheless, this library provides readable examples for developing gadgets, making it relatively easy for experienced $C++$ developers to build custom gadgets for their ZK applications without an in-depth knowledge of ZKPs. We recommend this framework to users that are building modular applications that benefit from CP-SNARKs, such as matrix arithmetic.  \n\nPySNARK. PySNARK [7] is a Python library that allows developers to use pure Python syntax to develop zkSNARKs with various backends. PySNARK gives users access to libsnark, qaptools, zkinterface, and snarkjs backends. Compiling computation with the libsnark and qaptools performs proof generation and verification using the Groth16 and Pinnochio proving systems, respectively. Using the zkinterface backend simply generates .zkif files that can be used with the zkinterface package for proof generation and verification, where the underlying scheme can be chosen. Similarly, using the snarkjs backend generates the witness and R1CS files that can be used within our provided snarkjs environment. Overall, PySNARK is a brilliantly documented and developed library for beginners with zk-SNARKs, however it is not actively maintained. Developers that are comfortable with Python should have no trouble developing ZK applications once they become familiar with the library’s syntax. Due to the Python compilation process, PySNARK experiences non-ideal operation times, so users should primarily use this for testing applications on the Groth16 proving system, but not for practical application development.  \n\nSnarkJS $^+$ RapidSNARK. SnarkJS [34] is built on Javascript (JS) and Pure Web Assembly (WASM) and supports the Groth16, PLONK, and FFLONK underlying proving schemes. This framework accepts circuits designed in circom [106], which provides a very accessible frontend with a well-documented API for building ZK circuits. The protocols that are supported all require trusted setup, whether it be a circuit-specific setup for Groth16, or a universal setup for PLONK/FFLONK. Also, switching between ZK schemes is simply done by specifying the desired scheme as a command line argument. SnarkJS provides a multi-step universal setup protocol that all programs perform, alongside a Groth16- specific setup. Alongside this, the circuit to proof compilation process is done in a modular way that allows for closer debugging. In the proof generation process, the circuit characteristic’s are listed for the developer (e.g. constraints, public inputs) which enables quick sanity checks. Finally, SnarkJS provides simple routes to turning the verifier into a smart contract, or performing the end-to-end ZKP process in browser, due to the JS and WASM backend. RapidSNARK [8] is built upon $C++$ and Intel assembly by the same developers, and significantly improves upon SnarkJS. Using a very similar API, and even accepting SnarkJS-generated files as inputs (e.g. proving/verifier keys, witness), RapidSNARK allows for faster proof generation with a simple change in command line arguments from the SnarkJS commands. The main advantage of this framework is the utilization of parallelization within proof generation, yielding much faster results than SnarkJS, however the downside is that only Groth16 proofs are supported. While SnarkJS is more actively maintained than RapidSNARK, both frameworks are highly accessible for those with little experience in developing ZK applications, due to the ability to utilize a circom frontend.  \n\nVirgo. Virgo [148] is an implementation of a novel interactive doubly-efficient ZK argument system. The main advantage of this protocol is the lack of trusted setup, which is oftentimes the most cumbersome task in zk-SNARKs. Virgo sees the most benefits for layered arithmetic circuits, rather than all general arithmetic circuits, as it is based off the GKR protocol [75], which also is only catered towards structured circuits. General arithmetic circuits are addressed in a follow up work, $\\mathtt{V i r g o++}$ [147]. The open-source implementation of this work does not have ZK commitments implemented yet, which is why we do not consider it in our survey. The main enabling factor of Virgo is a novel ZK verifiable polynomial delegation (zkVPD) scheme, which can essentially be seen as a commitment scheme in this scenario. Due to the reliance on zkVPD and the allowed interactivity in this scheme, the implementation only relies on lightweight cryptography, making it a feasible development solution. While an impressive solution with great results, the repository is not actively maintained and lacks clear documentation, meaning it is not the most suitable candidate for ZK application developers.  \n\nlibiop The libiop framework [118] is a collection of three protocol implementations: Aurora [39], Fractal [59], and Ligero [24]. Ligero falls under the MPCitH category, so it is discussed later in the paper. Aurora and Fractal are both post-quantum, transparent zk-SNARKs, which classifies them more as succinct zk-STARKs. However, the authors classify their work as zk-SNARKs, which is why they are discussed here. Both works outperform prior zk-SNARKs by proposing new interactive oracle proofs (IOPs). Fractal proposes a holographic IOP [29], while Aurora proposes an IOP based around Reed-Solomon codes. As for the libiop implementations, it does not seem to be actively maintained. While there are a few example applications for each protocol, the most useful tool in was the benchmarking scripts that were provided. This allows users to input parameters, such as number of constraints and variables, to specify a random circuit and outputs the performance metrics of the protocol. This shows how the protocols scale based on the size of the circuit. These parameters can be extracted from R1CS files (made by frameworks such as Zokrates), using our provided R1CSReader scripts. While the benchmarking is convenient, developing custom applications with this framework requires a deeper knowledge of the protocol that may not be easily accessible to all developers. We only recommend this to users that have a deep knowledge of the literature that these frameworks stem from.  \n\nNoir. Noir [17] is a general Rust-like framework for developing applications based on ZKPs. Fundamentally, Noir is a domain-specific language that resembles Rust. It enables one to build circuits that implement complex logic without having to learn the low-level details of ZKP systems. Since it acts like a generalized front end, it is capable of building circuits for a variety of back ends. Currently, Barretenberg [28] serves as the default back end, and generates PLONK proofs and Solidity contracts. The Barretenberg back end can also use WASM to create proofs and verify them directly in the browser. Arkworks is also available as an out-of-the-box back end, which can generate Groth16 and Marlin proofs. This generalization is possible because Noir framework compiles the circuit to an intermediate language referred to as ACIR (Abstract Circuit Intermediate Representation), which can then be further compiled to specific R1CS or arithmetic circuit compatible with a specific back end. The framework also provides a Typescript library for direct integration into web applications. There is active development going on, but Noir currently supports a full control flow with the ability to create custom circuits using readable code. This is a great option for developers who would like to avoid the details of ZKPs and build applications using a Rust-like DSL. We recommend this for those who want to build simplistic applications who have little experience with ZKPs.  \n\nDusk-PLONK. Dusk-PLONK [13] is a pure Rust implementation of the PLONK proving system. This implementation supports operation over the BLS12-381 and JubJub elliptic curves. The developers of this framework use Kate commitments [89] as their primary polynomial commitment scheme to utilize its homomorphism and maintain constant size commitments. The provided codebase is extremely detailed and well-commented and provides helpful documentation. Similar to other PLONK frameworks, Dusk-PLONK only provides a very low-level API for custom circuit development. To build a custom circuit, developers must translate their computation into an arithmetic or boolean circuit gate format (e.g. add, multiply). This is perfectly digestible for small circuits, as shown in the examples, however becomes an intensely laborious task as the circuit and number of inputs or input dimensions scales up. While the code is well-written and yields excellent results, this framework requires a more sophisticated high-level API that utilizes common software engineering structures to build custom circuits before new developers can start building practical ZKP applications with it. We do note that this is a fantastic implementation of the PLONK proving system for and recommend it for developers that have experience with logic design and ZKPs.  \n\nHalo2. Built by the same creators of Zcash and the original Halo [50] framework, the Halo2 framework [14] optimizes upon some of the inefficiencies of its predecessors by utilizing a PLONK-ish scheme as the underlying proving system. The underlying polynomial commitment scheme in this framework is Kate commitments. In its original repository and documentation, building a custom circuit with Halo2 requires a developer to design their computation in the form of a circuit, by implementing gates and utilizing them to build a chip. This can be relatively confusing for new developers. However, Halo2 is a powerful proof system that is utilized widely across the industry, including a prominent verifiable machine learning framework, ezkl [149]. This prominence has garnered a strong community backing the framework and has resulted in many works that either provide more examples of how the framework can be used [15], or expose higher-level APIs for building custom circuits. Overall, while the Halo2 framework only exposes a lower-level API for custom circuit building, the community around it makes it a relatively accessible solution for practical application of PLONKs. We believe this is a good framework for those experienced with applied cryptography and interest in building machine-learning focused applications.  \n\nB. MPC-in-the-head  \n\nLigero (libiop). The Ligero [24] protocol is implemented in libiop [118] framework. This interactive protocol applies the general IKOS [87] transformation that transforms MPCbased interactive proofs into ZKPs, which is typical for MPCin-the-Head (MPCitH) systems. This means that the key aspect of designing the Ligero is the underlying MPC protocol. While this protocol is interactive, it can be transformed into a zkSNARK using the Fiat-Shamir transform, just like any other interactive protocol. Additionally, the Ligero protocol only relies on collision resistant hash functions for the underlying cryptography and does not require a trusted setup. As this is implemented using the same backend as the Aurora and Fractal zk-SNARK protocols, all implementation details remain the same as described in section III-A.  \n\nLimbo. Similar to Ligero, Limbo’s implementation [94] and underlying protocol [63] is reliant on the IKOS transformation that MPCitH protocols often rely on. Limbo improves upon Ligero by highlighting the tradeoff between MPCitH parties involved, proof size, and runtime. The main work Limbo compares to is Ligero, as they are both transparent MPCitH schemes that only rely on collision resistant hash functions. Limbo claims to work better on small and medium circuits. While the Limbo framework is not as extensively developed, maintained, and documented as some of the other frameworks highlighted in this work, it greatly benefits from its ability to take Bristol Circuit (BC), a common way to describe MPC circuits [131], descriptions as inputs. This allows developers to build custom applications by describing their general computations in BC format. We provide a simple pipeline for developing BCs, alongside examples using readable syntax. We recommend this for users who have experience building optimized BCs and have a relatively deep understanding of MPC.  \n\nC. VOLE-Based ZK  \n\nDiet Mac’n’Cheese Diet Mac’n’Cheese [1] is a novel framework that implements the Mac’n’Cheese protocol [33], a Vector Oblivious Linear Evaluation (VOLE)- based zero-knowledge protocol over the $\\mathbb{Z}_{2^{k}}$ ring. Similar to $\\mathbf{MozZ}_{2^{k}}$ arella, this is a crucial step in making ZKPs more practical, as most real-world compute hardware operates on integer rings, and not finite fields. Diet $\\mathbf{{Mac^{\\prime}\\ n^{\\prime}}}$ Cheese makes many improvements to the state-of-the-art in VOLEbased ZK protocols by optimizing the underlying sVOLE subprotocol. This optimization yields significant performance improvements over prior VOLE protocols that operate over integer rings. The provided implementation comes in the form of a $C++$ package that directly implements the proposed scheme and uses the Swanky ecosystem [70] for easy integration. This framework is still in its early stages of development and currently lacks extensive documentation and concrete examples, making it harder for new ZKP developers to use it. Alongside this, Diet Mac’n’Cheese currently only supports fixed-point integer operations. It exposes a low-level API that requires a developer to explicitly define all computations as arithmetic and boolean gates that are operated on using the framework’s provided functions. However, a recent work has introduced a Python frontend with great documentation that can translate Python code into an intermediate representation that is recognized by the Diet Mac’n’Cheese framework. This frontend, entitled PicoZK [6], contains many examples and is even able to integrate with the popular numpy and pandas packages. PicoZK is a perfect pairing with Diet Mac’n’Cheese and allows for the development of simple applications. We recommend this framework to any developer that aims to build a scalable application that is conducive to a designated-verifier environment, such as federated or split learning. We do note that any floating point operations that are done with this framework must be converted to fixed-point.  \n\nemp-zk. The emp-zk development framework [139] is a part of the emp-toolkit [138], a collection of cryptographic front-ends and back-ends that allow for easy development of multi-party computation applications. Alongside ZKPs, emp-toolkit also provides libraries for garbled circuits and oblivious transfer. emp-zk has implementations of three novel interactive ZK systems:  \n\n• Wolverine [141], the first of these systems, presents a constant-round, scalable, and prover-efficient interactive ZK scheme.   \n• Mystique [142], built on top of Wolverine, focuses on machine learning applications. This work presents efficient conversions for arithmetic and boolean values, fixed-point and floating-point values, and committed and authenticated values.   \n• Quicksilver [144], also built on top of Wolverine, further improves communication costs and scalability.  \n\nThe main primitive these schemes take advantage of is subfield Vector Oblivious Linear Evaluation (sVOLE), which the authors extend and optimize for their ZK scheme. For sake of brevity, we spare the technical detail in this paper and refer to [140] for an excellent explanation. ${\\tt e m p-z k}$ provides a very user-friendly interface to all 3 ZK systems, with clear-cut examples. Although documentation is not explicitly provided, emp-zk largely relies on $C++$ syntax and does not require much knowledge about the underlying work in ZKPs, making it one of the more accessible options. One potential downside of these systems are that they are interactive, meaning all proofs are designated-verifier. We highly recommend this framework for users who are building custom machine learning-based custom applications that rely on floating-point operations, or applications that rely on scalability (e.g. database operations).  \n\n$\\mathbf{MozZ}_{2^{k}}$ arella. This work [32] presents a new protocol that utilizes an novel vector oblivious linear evaluation (VOLE), a tool from secure two-party computation, extension to perform zero knowledge proof operations efficiently over the integer ring $\\mathbb{Z}_{2^{k}}$ . This is very important as most ZK systems are made to operate over finite fields, which is not representative of modern CPUs. The proof system is coined with the term Quarksilver. This protocol outperforms the previous stateof-the-art VOLE-based works that operate over finite fields. The accompanying implementation enables development of ZK applications with the Quarksilver protocol as the underlying scheme. The MozZ2karella repository is not actively maintained, however has 3 sub-libraries for oblivious transfer, garbled and arithmetic circuits, and private set-intersection. Within these sub-libraries there are several examples that explain how to use the $\\mathtt{M O\\,Z\\mathbb{Z}_{2^{k}}\\,a\\,r\\,e\\perp\\mathrm{1\\,a\\,}}$ syntax, including examples for Quarksilver. While the examples are somewhat clear, using this library to build custom applications requires a deep knowledge of the underlying proof system, as users must be aware of the parameters that are being set on a per application basis. We only recommend this to users who’s applications fully rely on using the specific underlying protocol in this framework.  \n\nD. zk-STARKs  \n\nMiden VM. Miden VM [20] is a zero-knowledge virtual machine (zkVM) implemented in Rust, in which all programs that are run generate a zk-STARK that can be verified by anyone. Miden VM is designed as a stack machine, consisting of a stack, memory, chiplets, and a host. The stack, the main user-facing component, is a push-down stack of field elements, which is where inputs and outputs of operations are stored. Increasing the amount of inputs that are initialized on the stack before program execution increases the verifier cost. Whatever is left on the stack after program computation is declared as a public input to the verifier, which also increases cost to the verifier. A prover’s private inputs must be pushed to the stack during program computation to be kept private. The aim of Miden VM is, in their own words, to ”make Miden VM an easy compilation for high-level languages such as Rust” [18]. As these compilers do not yet exist, the only way to build custom circuits is using Miden’s assembly language, a very low-level API that interfaces with the Miden stack, and Miden chiplets, which are optimized assembly-based modules that perform common operations, like field arithmetic. Although Miden VM is Turing complete and offers standard control flow, it is often challenging for a developer to translate their desired computation to assembly commands and managing the stack at the same time, especially as the size of computation scales up. While Miden VM is a very valuable tool, we believe that its highest potential will be achieved upon completion of an accompanying compiler from a high-level language to Miden assembly. We recommend that users use this to benchmark certain atomic operations, but to avoid building custom applications with this framework due to the lack of a frontend.  \n\nZilch. The Zilch framework [105] consists of a Javalike frontend (ZeroJava) that interfaces with a novel zeroknowledge MIPS processor model (zMIPS) [133] to enable efficient interactive zk-STARK proof generation for custom computations. The ZeroJava frontend is highly sophisticated and is one of the only frameworks to enable an objectoriented programming approach. All ZeroJava programs are compiled into optimized and verifiable zMIPS instructions. As all of the instructions are verifiable, any program that can be expressed in ZeroJava can be verified using ZKPs. The underlying zMIPS processor can implement and verify any arbitrary computation in zero-knowledge. The zMIPS instructions are implemented using the zk-STARK library [38]. After computation description in ZeroJava and compilation to zMIPS, the constraints for the program are represent in algebraic intermediate representation (AIR) format. The prover and verifier interactively undergo the zk-STARK process until the verifier is convinced that the prover’s work is sound. Zilch provides an elegant and accessible approach to building custom circuits that utilize zk-STARKs. Although the works lacks dedicated documentation, the examples that are provided show that development of custom applications is almost as simple as implementing the program in Java, with a few ZeroJava design considerations. We recommend this for users with general knowledge of the MIPS instruction set architecture, which should allow them to build optimized programs.  \n\nRISC Zero. RISC Zero is a zkVM [115] implemented in Rust with an underlying RISC-V processor and instruction set architecture. The goal of this work is to produce publicly verifiable proofs of all the computations that are done within the framework. As the underlying instructions are derived from RISC-V, virtually any arbitrary computation can be expressed and verified in zero-knowledge. In this framework, custom circuits can be built using standard Rust syntax, with a few minor modifications to incorporates the framework’s API. This program is compiled to a set of RISC-V instructions, which is then executed within a RISC Zero session, which is recorded. A receipt of this session is recorded and used as part of the zk-STARK proof, which can be verified by any verifier to check validity of the computation. RISC Zero provides a relatively readable high-level Rust API, alongside several examples and very detailed documentation. Due to the maturity of the Rust development and RISC Zero as a whole, developers are able to import a majority of the most used standard Rust crates without trouble, enabling much more streamlined and efficient application development. For instance, developers can use the JPG crate [16] to build zeroknowledge applications around images. Alongside this, RISC Zero enables GPU acceleration, so that relevant applications can take advantage of computational speedup. We do note that although GPU acceleration is implemented in the RISC Zero codebase, we were not able to get it actually working due to some inconsistencies within the codebase. However, RISC Zero has an active community around it, including active development by the creators, and a very well-documented and accessible code, making it a great candidate for new developers of custom ZKP applications. The primary drawback for this framework is that, due the nature of zkVMs and the simulation of a RISC-V processor and ISA, this framework has relatively significant initialization and operation costs.\n\nZero-Knowledge Proof Frameworks: A Systematic Survey  \n\nNojan Sheybani1, Anees Ahmed2, Michel Kinsy2, Farinaz Koushanfar1 1UC San Diego, 2Arizona State University 1{nsheyban, farinaz}@ucsd.edu, 2{aahmed90, mkinsy}@asu.edu  \n\nAbstract—Zero-Knowledge Proofs (ZKPs) are a cryptographic primitive that allows a prover to demonstrate knowledge of a secret value to a verifier without revealing anything about the secret itself. ZKPs have shown to be an extremely powerful tool, as evidenced in both industry and academic settings. In recent years, the utilization of user data in practical applications has necessitated the rapid development of privacy-preserving techniques, including ZKPs. This has led to the creation of several robust open-source ZKP frameworks. However, there remains a significant gap in understanding the capabilities and real-world applications of these frameworks. Furthermore, identifying the most suitable frameworks for the developers’ specific applications and settings is a challenge, given the variety of options available. The primary goal of our work is to lower the barrier to entry for understanding and building applications with open-source ZKP frameworks.  \n\nIn this work, we survey and evaluate 25 general-purpose, prominent ZKP frameworks. Recognizing that ZKPs have various constructions and underlying arithmetic schemes, our survey aims to provide a comprehensive overview of the ZKP landscape. These systems are assessed based on their usability and performance in SHA-256 and matrix multiplication experiments. Acknowledging that setting up a functional development environment can be challenging for these frameworks, we offer a fully open-source collection of Docker containers. These containers include a working development environment and are accompanied by documented code from our experiments. We conclude our work with a thorough analysis of the practical applications of ZKPs, recommendations for ZKP settings in different application scenarios, and a discussion on the future development of ZKP frameworks.  \n\nI. INTRODUCTION  \n\nPrivacy-preserving cryptographic methods have become increasingly vital as privacy and data security evolve into a higher priority in new applications. Zero-Knowledge Proofs (ZKPs) enable a prover $\\mathcal{P}$ to prove to a verifier $\\mathcal{V}$ that a statement is true, without revealing any information beyond the validity of the statement itself. While ZKPs are most prominently known to the general public in blockchain applications [45], [48], [55], [57], they have also been effectively applied in many other real-world domains, such as healthcare [68], [121], [132], traditional finance [97], [114], [129], and government [30], [95]. ZKPs are an excellent solution for verifying data and computation in a secure fashion, however there are still many challenges before they can become a practical privacypreserving solution.  \n\nAlthough introduced in the 1980s [76], recent algorithmic and computing advances have garnered the evolution of ZKPs from a theoretical construct to a relatively practical cryptographic primitive. ZKPs have garnered the interest of researchers and developers as concerns over data privacy grow, which has caused significant improvements in both theory and implementation. The first significant milestone in the practical application of ZKPs was the development of zeroknowledge succinct non-interactive arguments of knowledge (zk-SNARKs) introduced by Ben-Sasson et. al [40] in 2013.  \n\nIn the decade since the introduction of zk-SNARKs, the zero-knowledge landscape has evolved to include a diverse set of ZKP constructions, such as zk-STARKs [38], which build off of zk-SNARKs and are discussed at length in this work. For many of the ZKP constructions that are available, there are several prominent frameworks, stemming from industry and academia, that allow developers to create their own ZKP applications. Despite the availability of these open-source frameworks and the demand of privacy-preservation in real-world systems, the implementation of ZKPs in practical applications has been limited. This can be attributed to three ongoing challenges: 1) performance; 2) usability; 3) accessibility. These are the attributes that we evaluate the chosen open-source frameworks on in this work. The journey towards making ZKPs a de facto solution for privacy-preserving applications is hamstrung by the performance, due to the complexity of current accessible ZKP protocols. In this work, we hope to find the schemes with the best performance for each type of ZKP construction, evaluated over several metrics on CPU and we will discuss the next steps that can be taken towards practical ZKP adoption.  \n\nUsability and accessibility are common problems that face privacy-preserving technologies, especially those stemming from academia, and the ZK landscape is no different. Due to the surge of research that has been done in the ZK space, there has been a sudden increase in the number of available frameworks for developers. For a nascent developer of ZKP applications, especially one with little exposure to cryptography and ZK concepts, this can seem like a near-impossible field to navigate. Even for experienced developers, these frameworks are often hard to use, due to their (mostly) poor documentation or reproducible examples. While this is understandable in academic settings, due to time and resource constraints, a significant step towards enabling practical ZKP usage is demystifying the currently existing frameworks and lowering the barrier of entry for experienced and unexperienced developers. Alongside this, it is also currently difficult for developers to decipher whether a framework is usable for their custom application, due to the different ZKP constructions available, each with different underlying arithmetic, security guarantees, and interaction/communication requirements.  \n\nWhile there is no arguing that the development of the open-source ZKP frameworks has significantly reduced the amount of necessary effort for building new applications, the field is still difficult to navigate. The available open source frameworks have been used to enable secure verification of computation, data, and identity in the domains of machine learning [146], networking [82], IP protection [122], and many more. Although there has been this evident uptick in ZKP frameworks and applications, there is no overview of the ZK landscape that is both cryptographer and non-cryptographer friendly. Alongside this, it is hard to find a clear path for where ZKPs can be improved so they can be more broadly integrated into practical real-world applications.  \n\nThis paper aims to provide users with a guide to ZKPs and the available ZKP frameworks, allowing readers to gain a high-level overview of the ZK landscape, while also providing new quantitative benchmarks and details for developers to choose the best ZKP framework for their application. To achieve this goal, we conduct an extensive survey of the ZK landscape, gathering several state-of-the-art frameworks representing the seminal ZKP constructions. We first evaluate these existing tools based on the usability and accessibility of their repositories for a non-experienced cryptographic application developer, highlighting their features and shortcomings from a design standpoint. We then evaluate a subset of the most accessible and usable frameworks, primarily those that expose a high-level API, based on their performance through an indepth analysis of their runtime and communication complexity. Performance is measured over two custom benchmarks that represent commonly used functions in privacy-preserving computation: matrix multiplication and SHA-256 compression.  \n\nWe provide a discussion of the different constructions at a high-level to guide developers in their choice of framework. Our experimental evaluation, insights, and recommendations should provide a general guide to developers on how to whittle down the available frameworks to ones that fit their application setting, bandwidth, and computational requirements. We conclude our work with a discussion on some of the cutting-edge applications that ZKPs have been utilized in, the challenges that ZKP applications currently face, and the future of ZKPs.  \n\nUnfortunately, many of the prominent works that provide open-source frameworks do not include a proper documentation or reproducible examples, thus hindering developers in integrating these frameworks into their applications. Alongside this, many of the frameworks require complex local environment build dependencies. To combat this hurdle, we provide a new open-source Github repository1 containing all the tools necessary to build a custom ZKP application with any framework discussed in this survey. Not only do we provide open-source Docker environments for each frameworks with reproducible documented examples, but we also include Docker containers for other helpful tools, such as circuit building and inspection tools. This repository is also well-documented and actively maintained to encourage users to immediately start building custom applications, rather than focusing on setup troubles.  \n\nThe goal of this survey is to lower the barrier of entry to building ZKP applications by providing an in-depth overview of ZKPs, the existing constructions, the available open-source frameworks and their capabilities, and the usability, accessibility, and performance of each available framework. This paper is written so that a reader with no prior knowledge of ZKPs can garner a high-level understanding of the landscape, while experienced readers can sharpen their knowledge of the details of ZKPs and gain insights on the available tools for ZK-based application development. In short, our scientific contributions are:  \n\n• We present the first survey of open-source ZKP frameworks, spanning all ZKP constructions, with accompanying open-source environments for each framework, including benchmarks and documentation.   \n• We perform extensive analysis of select open-source ZKP frameworks on scalability, runtime, and proof size on two benchmarks representing prominent domains of ZKPs in current practice.   \n• We provide a thorough analysis of the capabilities, usability, and accessibility of each open-source ZKP framework. Based on the insights of our work, we customize suggestions of frameworks for different use cases based on available compute power, developer experience, and application type. Finally, we provide novel insights on the current state of ZKP and the necessary path to further boost practicality.  \n\nA. Related Work  \n\nTo the best of our knowledge, this work is the first to systematically survey and benchmark open-source ZKP frameworks spanning all constructions for practical settings and realization. [56], [130] have considered a very limited amount of frameworks, but their industry-led work is largely comparing different constructions to each other (zk-SNARK vs. zk-STARK), rather than comparing frameworks of the same construction to each other (zk-SNARK vs. zk-SNARK). While there are very interesting insights made, we believe that our work is much more objective, systematic and extensive, while also adding the element of usability and accessibility analysis. Another survey on ZKP frameworks has been conducted [127], however this work only focuses on zk-SNARKs and does not look into the usability, accessibility, or performance of the chosen frameworks. Also, the work is largely focused on the application of zk-SNARKs in the blockchain. Similarly, [111] conducts a survey on non-interactive ZK applications in the blockchain. The main focus of this work is the analysis of privacy-protection schemes for smart contracts. This work approaches ZK scheme analysis from a theoretical standpoint. Rather than focusing on usability and accessibility, this work primarily focuses on analyzing the asymptotics of the available schemes. Unfortunately, this is not fully representative of the performance of these schemes in practice, due to some schemes having high constants in their asymptotic complexities. While we believe that surveying zk-SNARKs is very important, we note that many zk-SNARK schemes are not post-quantum secure. As post-quantum security becomes a rapidly growing concern, our work purposefully inspects every available ZKP construction to provide insights into postquantum secure frameworks, alongside more established zkSNARK frameworks. We believe that limiting our work to zk-SNARKs would not be fully representative of the ZK landscape.  \n\nWe model our paper after the seminal surveys in privacypreserving technology centered around MPC [84] and FHE [134]. Like these works, we aim to provide as detailed of a description as we can surrounding the usability, accessibility, and performance of our chosen frameworks, while providing a digestible guide for developers choosing a tool for their ZKbased applications.  \n\nII. ZERO-KNOWLEDGE PROOFS  \n\nZero-Knowledge Proofs (ZKPs) are a cryptographic primitive that allow a prover $\\mathcal{P}$ to prove to a verifier $\\nu$ that they know a secret value $w$ , called the witness, without revealing anything about $w,\\ \\mathcal{P}$ does this by showing that they know a secret value $w$ such that $\\mathcal{F}$ evaluated at $w$ equals some public output $y$ . Formally, $\\mathcal{P}$ sends a proof attesting that ${\\mathcal{F}}(x;w)\\,=\\,y$ , where $x$ and $y$ are public inputs and outputs, respectively. ZKPs have three core attributes [74]:  \n\n1) Soundness: $\\mathcal{V}$ will find out, with a very high probability, if a $\\mathcal{P}$ is dishonest if the statement is false.   \n2) Completeness: An honest $\\mathcal{P}$ can convince $\\mathcal{V}$ if the statement is true.   \n3) Zero-Knowledge: If the statement is true, $\\mathcal{V}$ will learn nothing about the $\\mathcal{P}$ ’s private inputs - only that the statement is true.  \n\nIn the following sections, we discuss the evolution of ZKPs, the nuances of specific classes and schemes, and provide a detailed overview of the current ZK landscape.  \n\nA. Taxonomy of ZKPs  \n\nIn this work, we analyze 25 ZK protocols. Amongst these protocols are a mix of interactive and non-interactive schemes. An in-depth explanation of the difference between interactive and non-interactive schemes can be found in Appendix A. From now on, we describe computation as circuits $\\mathcal{C}$ , as that is what they are referred to as in ZK literature. This is due to the process of arithmetization, which represents functions, such as Python $/C++$ code, as arithmetic circuits, then converts these circuits into a mathematical representation (e.g. polynomials) that can be used within ZKPs. Oftentimes, an intermediate step between the input and output is a set of constraints that describes the code/circuit. These constraints act as the basis for the mathematical representation. For brevity’s sake, we do not discuss the details of arithmetization and refer to the brilliant explanations of [12], [52]. In this text, we only treat arithmetization as a black-box and do not require the knowledge of specific details, only the inputs (e.g. code) and outputs (e.g. mathematical representation). Table I compares the seminal ZK protocols at a high-level. Below, we describe the taxonomy of the general schemes that underlie our chosen ZK protocols in detail.  \n\nZero-Knowledge Succinct Non-Interactive Arguments of Knowledge (zk-SNARKs) are, as the name suggests, a class of non-interactive protocols that boast small proof size [40]. Although ZKPs were originally conceived in the late 1980’s [76], zk-SNARKs were formally introduced about a decade after. Efficient instantiations of zk-SNARKs were introduced in the last decade, resulting in recent advancements in making zk-SNARKs practical and efficient for widespread use. This means there are much more mature open-source and realworld implementations available. The most common forms of zk-SNARKs are referred to as pre-processing zk-SNARKs. One of the main drawbacks of these zk-SNARKs are that they require a trusted setup for every new circuit $\\mathcal{C}$ , which is computationally intensive and requires communication of large proving and verifying keys to the respective parties. Alongside this, $\\mathcal{P}$ must normally be computationally powerful in order to ensure small proof size. This is due to the fact that most zk-SNARKs are reliant on elliptic curve cryptography (ECC) as their underlying cryptographic arithmetic. Recent works have introduced zk-SNARKs that can utilize universal trusted setups [58], [69] for established maximum circuit sizes, and zk-SNARKs that do not require a trusted setup at all [120], [137]. Due to the non-interactivity, zk-SNARKs are publicly verifiable, meaning any verifier can verify them without recomputing the proof. One of the most common underlying schemes, especially in our highlighted frameworks, for zkSNARKs is Groth16 [79], which improves upon the original Pinocchio [110] protocol. zk-SNARK arithmetization typically results in a set of constraints, called Rank 1 Constraint Systems (R1CS) [36], which are then converted to a set of polynomials, called a Quadratic Arithmetic Program (QAP) [72]. We do note that there are different formats that are zk-SNARKs are compatible with, such as Algebraic Intermediate Representations (AIR) [38] and Plonkish tables - we simply highlight R1CS as a prevalent constraint system. The Groth16 zkSNARK generation and verification process can be represented at a high-level with the following algorithms:  \n\n• $(\\mathcal{V}\\mathcal{K},\\mathcal{P}\\mathcal{K})\\gets\\mathrm{Setup}(\\mathcal{C})$ : A trusted third party or $\\nu$ run a setup procedure to generate a prover key $\\mathcal{P}K$ and verifier key $\\mathcal{V}\\kappa$ . These keys are used for proof generation and verification, respectively. This setup must be repeated each time $\\mathcal{C}$ changes. • $\\pi\\;\\leftarrow\\;\\operatorname{Prove}({\\mathcal{P K}},\\;{\\mathcal{C}},\\;x,\\;y,\\;w)\\colon\\;{\\mathcal{P}}$ generates proof $\\pi$ to convince $\\mathcal{V}$ that $w$ is a valid witness. • $1/0\\leftarrow$ Verify $(\\mathcal{V}K,\\mathcal{C},\\,x,\\,y,\\,\\pi){:\\:}\\mathcal{V}$ accepts or rejects proof $\\pi$ . Due to soundness property of zk-SNARKs, $\\nu$ cannot be convinced that $w$ is a valid witness by a cheating $\\mathcal{P}$ .  \n\nIn Appendix B, we describe how zk-SNARKs can be extended to allow recursive construction and verification of proofs.  \n\nAs we stated, one of the drawbacks of traditional preprocessing zk-SNARKs is their reliance on a trusted setup per circuit $\\mathcal{C}$ . PLONKS, a subset of zk-SNARKs, are a class non-interactive ZK protocols that improve upon preprocessing zk-SNARKs by getting rid of the trusted setup per circuit $\\mathcal{C}$ , while adding a bit more arithmetic flexibility [69]. PLONKs utilize the idea of a universal and updatable trusted setup, introduced in theory by [80] and in practice by [103], in which a trusted setup procedure is done for circuits up to a certain size. Every circuit $\\mathcal{C}$ that fits within these size constraints can utilize the parameters generated by the universal trusted setup process. While PLONKs introduce a universal trusted setup, it comes at the cost of proof size  \n\nConstructionKey AdvantagesKeyDisadvantageszk-SNARKsSuccinct,PubliclyVerifiableTrusted SetupRequired, ComputationallyExpensive toProve,Not Post-Quantumzk-STARKsNoTrustedSetup,Post-QuantumSecure,ScalableProver,PubliclyVerifiableLargerProof Sizes,SlowVerificationMPCitHNoTrusted Setup,Post-QuantumSecure,PubliclyVerifiableSlowVerification,ComputationallyExpensiveProvingVOLE-ZKHighest Scalability,NoTrusted Setup,Post-QuantumSecureSlowVerification,DesignatedVerifier  \n\nTABLE I: Core Attributes of Popular ZKP Constructions   \n\nzk-SNARKszk-STARKsMPCitHVOLE-ZKProver complexityO(nlog(n))O(npoly-log(n))O(n)O(n)Verifiercomplexity0(1)O(poly-log(n))O(n)O(n)Proof size0(1)O(poly-log(n))(u)O(u)OTrusted setupNon-interactivePost-quantum securePracticalproofsize120-500bytes10 KB - 1 MB10-1000 KB5-200KB  \n\nTABLE II: Asymptotic attributes of presented ZKP constructions. We do note that, due to the variance of schemes within each construction, the algorithmic complexities are generalized and may not hold true for all schemes within a given construction.  \n\nand $\\mathcal{V}$ runtime. PLONK proofs are normally $2\\,-\\,5\\times$ the size of zk-SNARKs, and $\\mathcal{V}$ runtime is marginally higher. It is important to note that, although PLONK proofs are larger than those of zk-SNARKs, proof size still remains in the KB range. The advantage that PLONKs have is that they are flexible in the commitment scheme they can use. By using the standard Kate commitments [89], PLONKs become more zk-SNARK-like, as these commitments are based on ECC. FRI commitments [37], which rely on Reed-Solomon codes and low-degree polynomials/testing for verifiers, can also be used to make PLONKs more zk-STARK-like. The type of commitment schemes allows developers to balance the tradeoff between performance and security assumptions. PLONK arithmetization is similar to that of zk-SNARKs, meaning that the resulting representation is a set of polynomials. To get there, PLONKs sets constraints for each gate (e.g. multiplication, addition) from the arithmetic circuit representation of the computation in the form of Lagrange polynomials. Once the constraints are set, a special permutation function is used to check consistency between commitments. Finally, a final set of polynomials is constructed to fully represent the given computation. Overall, PLONKs provide a method to flexibly construct ZKPs with a less stringent trusted setup requirement, at the slight cost of performance.  \n\nZero-Knowledge Scalable Transparent Arguments of Knowledge (zk-STARKs), which can be thought of as interactive oracle proof (IOP)-based zk-SNARKS, completely remove the dependence on trusted setup. Rather than using randomness from a trusted party, these protocols use publicly verifiable randomness for generating the necessary parameters for proof generation and verification. zk-STARKs achieve post-quantum security guarantees by utilizing collision-resistant hash functions as their underlying cryptography, rather than ECC. This increased security comes at a cost, as zk-STARK proofs are typically an order of magnitude larger than zk-SNARKs and PLONKs, and require more computational resources to generate and verify [38]. The main contributor towards these drawbacks are the underlying data structure that are used in proof generation: Merkle trees. In zk-STARKs, Merkle trees are used to create a compact representation of the computation’s execution trace. During proof generation, the computation’s execution trace is arithmetized into polynomials, which are verified by performing low-degree testing, a process which ensures that the polynomials are of expected degree. Low-degree testing is enabled by the use of FRI commitments [83]. The polynomials are evaluated at certain points to verify their correct represenation of the execution trace, and these evaluations are used as the leaf nodes of the Merkle tree. The root of the Merkle tree then acts as a sort of commitment to these evaluated polynomials, hence allowing the verifier to simply verify the root, rather than verifying the whole computation trace. [27] The use of Merkle trees are what enable the scalability of zk-STARKs. While the Merkle trees support efficient verification, the proof size is drastically increased due to the inclusion of the material needed for verification, such as the Merkle root, polynomial evaluations, FRI commitments, and necessary Merkle branches. We note that there are IOP-based zk-SNARKs that stray away from this general protocol, but these steps are the most consistently utilized in current literature. Overall, zk-STARKs primarily benefit from being scalable and post-quantum secure with no trusted setup, at a significant cost to proof size and $\\mathcal{P}/\\mathcal{V}$ computation.  \n\nMPC-in-the-Head (MPCitH) ZKPs are a class of ZK protocols that take a completely novel approach towards proof generation and verification. The primary cryptographic basis is secure multiparty computation (MPC). MPC is a cryptographic primitive that allows for $n$ parties to jointly compute a function $f(x_{1},...,x_{n})$ , on private inputs from each party, without leaking any information about the private inputs. One of the prominent approaches to enable MPC is secret sharing, in which parties distributes secret shares of their private inputs amongst each other to compute a function. MPCitH, proposed by [87], allows for $\\mathcal{P}$ to simulate the $n$ MPC parties and following computation locally, or ”in the head”. Theoretically, any MPC protocol that can compute arbitrary functions can be transformed into a MPCitH ZKP. For $n$ parties $\\{P_{1},...,P_{n}\\}$ , secret shares are generated by each party and distributed to every other party. For the underlying arithmetic, the circuit $\\mathcal{C}$ is defined in an MPC manner to operate on secret shared data. $\\mathcal{P}$ can then simulate each parties’ computation of the circuits with the secret shares they obtained from all other parties. After this is complete, $\\mathcal{P}$ has $n$ sets of messages and data that were generated and received by each party, called views. $\\mathcal{P}$ uses a standard commitment scheme to generate $n$ view commitments. Finally, $\\mathcal{P}$ and $\\nu$ interactively verify a subset of these views for consistency and correctness [124]. While MPCitH protocols are innately interactive, they can be made non-interactive using the Fiat-Shamir transform. Theoretically, a huge advantage of the MPCitH approach is that MPCfriendly optimizations, which have been much further studied, can be utilized during proof generation to drastically improve $\\mathcal{P}$ efficiency and proof length. However, the most effective optimizations for MPC may translate to effective solutions for MPCitH. One of the core parameters MPCitH schemes aim to minimize is the communication complexity, as this directly reduces the amount of data that is present in each party’s committed view. Just like zk-STARKs, MPCitH-based ZKPs do not require a trusted setup and are post-quantum secure, as MPC is thought to be generally quantum secure [124]. Overall, MPCitH proposes a unique approach towards ZKP construction that are transparent post-quantum secure that allows flexibility in the underlying arithmetic to optimize the cost of proof generation and verification and proof size.  \n\nVector Oblivious Linear Evaluation (VOLE)-based ZK protocols are a set of interactive techniques that achieve high efficiency and scalability through the use of informationtheoretic message authentication code (IT-MAC)-based commitment schemes, which can be efficiently implemented using VOLE correlations. In VOLE-based ZKP protocols, the prover acts as the VOLE sender, while the verifier takes on the role of the VOLE receiver. VOLE correlations are a pair of random variables, $(\\mathbf{u},\\,\\mathbf{x})$ , known by $\\mathcal{P}$ and $(\\mathbf{v},\\,\\Delta)$ , only known by $\\nu$ , in which $\\mathbf{u},\\ \\mathbf{X},$ and $\\mathbf{v}$ are vectors, and $\\Delta$ is a scalar key []. These variables satisfy the relation:  \n\n$$\nu_{i}=v_{i}+x_{i}\\cdot\\Delta\n$$  \n\nThis functionality typically operates over a finite field. Generally, in VOLE-based ZK, IT-MACs are used as commitments to authenticated wire values in arithmetic or boolean circuits representing a computation $\\mathcal{C}.~\\mathcal{P}$ demonstrates knowledge of a private vector $\\mathbf{w}$ , which represents the witness, where $\\mathcal{C}(\\mathbf{w})~=~1$ , while proving the consistency throughout the protocol, without revealing any information about w. VOLEbased proofs provide unparalleled scalability and communication optimizations, however, they are inherently designatedverifier protocols, meaning that $\\mathcal{P}$ must communicate with every $\\mathcal{V}$ that aims to verify the proof, as $\\mathcal{V}$ must maintain the secret $\\Delta$ to ensure soundness. To address this, [31] proposes a new VOLE-based paradigm, entitled VOLE-in-thehead (VOLEitH), which enables non-interactive VOLE-based ZK.  \n\nIII. ZKP LIBRARIES  \n\nIn this section, we discuss the details of the 25 frameworks that we target in this work. We aim to highlight frameworks bred from both industry and academia. We primarily focus on works that present novel implementations of proving schemes that can be integrated with their own exposed high-level API for custom circuit design, or a general-purpose ZKP circuit development frontend, such as Circom [106] or Zokrates [64].  \n\nAlongside the in-depth descriptions of each framework, we provide an evaluation of these frameworks at a high-level on usability and accessibility metrics, presented in Table III. Our measurement of some metrics require further explanation:  \n\n• Custom C: $\\bullet=$ Non-cryptography software engineer can build custom circuits, $\\mathbf{\\dot{O}}=$ Building custom circuits requires deep knowledge of syntax; A developer could not read the code and understand it, $\\bigcirc=$ Custom circuits require deep knowledge of protocol and syntax; normally requires manual translation of constraints to gates • Examples: $\\bullet=$ Plenty of examples are shared that fully show the capabilities of the system, $\\pmb{\\mathbb{O}}=$ Examples are included, but are not representative of the system’s full capabilities • Github Issues: $\\bullet=$ Users and developers are both active in issues forum, $\\pmb{\\mathrm{O}}=$ Users are relatively active and developers are sporadically active, $\\bigcirc\\!\\!=\\!\\!\\mathrm{No}$ activity  \n\nTable V in Appendix C outlines the discussed frameworks at a high level.  \n\nA. zk-SNARKs  \n\nlibsnark. The libsnark $C++$ development library [4] is widely regarded as the original and most well-developed library for zk-SNARKs. This is highlighted by the fact that Zcash, the first real-world implementation of zk-SNARKs, was built upon libsnark. libsnark supports the Pinocchio [110] and Groth16 [79] proving schemes, alongside many different underlying elliptic curves. Much of the novelty of libsnark comes from the different forms of circuits that it supports. It supports R1CS and QAPs, as most frameworks do, but also supports higher level forms such as Unitary-Square Constraint Systems (USCS) and Two-input Boolean Circuit Satisfiability (TBCS) [62]. The scheme used in libsnark is described as a preprocessing zk-SNARK, which simply highlights that trusted setup is performed before proof generation and verification. libsnark provides low-level ”gadgets”, which can be combined and built upon to represent the desired computation in R1CS format, however it is not the easiest way to develop zk-SNARKs in this library. [92] presents xJsnark, a high-level Java framework that allows a user to essentially code their computation in standard Java. Behind the scenes, this framework optimizes computation and outputs the computation in R1CS format. This output can be used directly with libsnark’s zk-SNARK generation script. Combined with xJsnark, libsnark is a highly-accessible option for inexperienced ZKP developers.  \n\ngnark. The gnark library [49] enables developers to build zk-SNARK-based applications using the high-level API it offers in Go language. The primary focus of gnark is runtime speed [60]. It offers both Groth16 [79] and PLONK [69] (with KZG and FRI polynomial commitment) SNARK protocols. It offers a lot of curves, and can build R1CS circuits. In terms of hashing, it offers MiMC [23], SHA2, and SHA3 gadgets out-of-the-box. It also offers a collection of high-level gadgets for ease of building custom circuits. This framework exposes a high-level API that allows users to build their own gadgets, while utilizing the Go standard language and the provided gadgets. Recently, gnark has introduced GPU support with the support of the Icicle library [86]. This work is in active", "files_in_pdf": [{"path": ".pdf_temp/viewrange_chunk_2_6_10_1761837414/images/vu2ae3.jpg", "size": 278677}, {"path": ".pdf_temp/viewrange_chunk_1_1_5_1761837415/images/nniwj7.jpg", "size": 87383}, {"path": ".pdf_temp/viewrange_chunk_1_1_5_1761837415/images/epram9.jpg", "size": 52903}]}