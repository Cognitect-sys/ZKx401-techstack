{"origin_pdf_path": "https://eprint.iacr.org/2019/458.pdf", "text_in_pdf": "POSEIDON: A New Hash Function for Zero-Knowledge Proof Systems (Updated Version)  \n\nLorenzo Grassi1, Dmitry Khovratovich2, Christian Rechberger3, Arnab Roy4, and Markus Schofnegger3  \n\n1Radboud University Nijmegen 2Ethereum Foundation and Dusk Network 3IAIK, Graz University of Technology 4University of Klagenfurt rassi@cs.ru.nl, khovratovich@gmail.com, firstname.lastname@iaik.tugraz.at, arnab.roy $@$ a  \n\nAbstract  \n\nThe area of practical computational integrity proof systems, like SNARKs, STARKs, Bulletproofs, is seeing a very dynamic development with several constructions having appeared recently with improved properties and relaxed setup requirements. Many use cases of such systems involve, often as their most expensive part, proving the knowledge of a preimage under a certain cryptographic hash function, which is expressed as a circuit over a large prime field. A notable example is a zero-knowledge proof of coin ownership in the Zcash cryptocurrency, where the inadequacy of the SHA-256 hash function for such a circuit caused a huge computational penalty.  \n\nIn this paper, we present a modular framework and concrete instances of cryptographic hash functions which work natively with $\\mathrm{GF}(p)$ objects. Our hash function POSEIDON uses up to 8x fewer constraints per message bit than Pedersen Hash.  \n\nOur construction is not only expressed compactly as a circuit, but can also be tailored for various proof systems using specially crafted polynomials, thus bringing another boost in performance. We demonstrate this by implementing a 1-outof-a-billion membership proof with Merkle trees in less than a second by using Bulletproofs.  \n\nPrevious Versions. This paper is an updated version of $[\\mathrm{GKR}^{+}19]$ and $[\\mathrm{GKR}^{+}21]$ published at USENIX 2021. The main differences are as follows.  \n\n• In this updated version, we limit ourselves to POSEIDON over a prime field $\\mathbb{F}_{p}^{t}$ instantiated with $x\\mapsto x^{\\alpha}$ , where $\\mathbf{{\\alpha}}\\geq3$ is the smallest positive integer that satisfies $\\operatorname{gcd}(\\alpha,p-1)=1$ . The reasons of this choice are due to the fact that (i) all applications we consider are more efficient when working with a prime field rather than a binary field, and that (ii) the version of POSEIDON instantiated with $x\\mapsto x^{-1}$ is not used in any practical application (to the best of our knoweldge).  \n\n• The security analysis has been updated. In particular, with respect to the earliest version, a further assumption on the linear layer has been added in order to take into account the recent attacks proposed in [KR21, $\\mathrm{BCD}^{+}20\\mathrm{J}$ . With respect to the latest one, we fixed some flaws and mistakes present in the security analysis of the Gröbner basis attacks. We also include the new results from [ABM23] in our updated analysis.  \n\n• The applications part and the comparison with respect to other schemes have been updated.  \n\nWe emphasize that both (i) the entire family of STARKAD and (ii) POSEIDON instantiated with $x\\mapsto x^{-1}$ are considered as dismissed, and we advice against using them. We also recommend using the formula proposed in this updated version for computing the number of rounds of POSEIDON (note that the new round numbers are equal to the previous ones for all use cases we are aware of).  \n\nContents  \n\n1 Introduction 2  \n\n2 The POSEIDON Hash Function 4   \n2.1 Sponge Construction for POSEIDONπ 5   \n2.2 The HADES Design Strategy for Hashing 5   \n2.3 The Permutation Family POSEIDONπ 6  \n\n3 Applications  \n\n1 Concrete Instantiations of POSEIDONπ 8   \n4.1 Main Instances 8   \n4.2 Domain Separation for POSEIDON 8   \n5 Cryptanalysis Summary of POSEIDON 9   \n5.1 Definitions . . 9   \n5.2 Security Claims 9   \n5.3 Summary of Attacks 9   \n5.4 Security Margin 9   \n5.5 Attack details 10   \n5.5.1 Statistical Attacks 10   \n5.5.2 Algebraic Attacks 10   \n6 POSEIDON in Zero-Knowledge Proof Systems 11   \n6.1 State of the Art 12   \n6.2 SNARKs with POSEIDONπ 12   \n6.2.1 Groth16 12   \n6.2.2 Bulletproofs 13   \n6.2.3 PLONK 13   \n6.2.4 RedShift 14   \n6.3 Comparison with Other Hash Algorithms 14   \n6.4 STARKs with POSEIDONπ 15  \n\n7 Acknowledgements 15  \n\nA Auxiliary Files 20  \n\nB Efficient Implementation 20  \n\nC Security Analysis: $x^{\\alpha}$ -POSEIDONπ 21   \nC.1 Statistical Attacks . 21   \nC.1.1 Differential Cryptanalysis 21   \nC.1.2 Linear Cryptanalysis 22   \nC.1.3 Truncated Differential 22   \nC.1.4 Rebound Attacks 22   \nC.1.5 Invariant Subspace Attack 23   \nC.2 Algebraic Attacks . . 23   \nC.2.1 Interpolation Attack 23   \nC.2.2 Gröbner Basis Attack 24  \n\nD Compact Constraints for STARKs and SNARKs 26  \n\nE Initialization of the Grain LFSR Used for Parameter Generation 27   \nF Concrete Instances with Security Margin 28   \nG Selecting Number of Rounds in General Case 28   \nH Merkle Tree Instances of POSEIDON 29   \nI About STARKAD (Currently Dismissed) 29 I.1 The Permutation STARKADπ 29 I.2 Cryptanalysis and Old Number of Rounds of STARKADπ 30  \n\nJ About $x^{-1}$ -POSEIDON (Currently Dismissed) 30  \n\n1 Introduction  \n\nThe recent advances in computational integrity proof systems made a number of computational tasks verifiable in short time and/or in zero knowledge. Several protocols appeared that require one party to prove the knowledge of a seed-derived secret, of an element being part of a large set, or their combination. Whereas accumulator-based solutions [CL02,CKS09] and algebraic Schnorr proofs exist in the area, they are quite involving and thus error-prone, require a trusted setup, are limited in statement language, and are often slow. An alternative is to express secret derivation using cryptographic hash functions, and to prove set membership by presenting an opening in a properly chosen Merkle tree, also built on a cryptographic hash function. Such hash-based protocols require a computational integrity proof system, which can be applied to an arbitrary arithmetic circuit. However, for the protocol to be efficient, proofs must be generated and verified in reasonable time, which in turn requires the hash function to be cheap in a certain metric depending on the proof system.  \n\nIn the middle of 2020, the most popular proof systems are ZK-SNARKs (Pinocchio [PHGR13], Groth16 [Gro16], PLONK [GWC19], Marlin $[\\mathrm{CHM}^{+}20]$ to name a few), Bulletproofs $[\\mathbf{BBB}^{+}18]$ , ZK-STARKs [BBHR19], and MPC-in-thehead systems [GMO16,AHIV17, $\\mathrm{CDG^{+}17]}$ . The former two groups have already been applied to a number of real-world protocols, whereas the latter ones are the most promising from the perspective of post-quantum security. These systems use two quite different circuit descriptions so that the proof size and generation time are computed differently:  \n\n• The R1CS format (rank-1 quadratic constraints) describes the circuit as a set of special quadratic polynomials of the form $L_{1}(X)\\cdot L_{2}(X)=L_{3}(X)$ , where $X$ is the tuple of internal and input variables, $L_{i}$ are affine forms and $\\cdot$ is the field multiplication, and (possibly in an affine-equivalent form) is used in almost all SNARKs and Bulletproofs. The circuit multiplication and addition gates are defined over a prime field $\\mathrm{GF}(p)$ . The proof generation complexity is directly proportional to the number $T$ of constraints, which often corresponds to the number of multiplication gates. The prime field $\\mathrm{GF}(p)$ is the scalar field of an elliptic curve, where for ZK-SNARKs the curve should be pairing-friendly and for Bulletproofs it should just be a secure curve.  \n\n• The AET metric is used in ZK-STARKs and (to some extent) in the PLONK proof system. The computation is expressed as a set of internal program states related to each other by polynomial equations of degree $d$ . The state consists of $w$ field elements and undergoes $T$ transformations. The proof generation is roughly proportional to the product $w\\cdot d\\cdot T$ . The number and sparsity of polynomial constraints do not play a major role.  \n\nOur goal was to design a family of hash functions that are optimal in the R1CS (as the most widespread) and good in the AET metric, while also supporting different finite field sizes. It turned out that the substitution-permutation network (SPN) design, well-known in symmetric cryptography, allows for a generic hash function framework where the only security-critical parameter that has to be changed for each instance is the number of rounds, and we provide an efficient and transparent strategy for its choice. The S-box is chosen as the power map $x\\mapsto x^{d}$ , where $d\\geq3$ is usually chosen as the smallest integer that guarantees invertibility and provides nonlinearity. In particular, the cube function $x^{3}$ is almost universally chosen, apart from cases of fields where this function is not a bijection. Instead, we suggest other S-boxes such as $x^{5}$ or $1/x$ for these cases. Thanks to a succinct representation of the functions and a low S-box degree, we are able to optimize the circuit significantly for PLONK and RedShift proof systems, with performance improvements by a factor of up to 40.  \n\nTable 1: Our primary proposals and their competitors. “Tree” refers to the Merkle tree arity and is equal to the rate/capacity ratio. “Curve” denotes the curve (BLS12-381, BN254, Ed25519) whose (subgroup) scalar field determines the prime size. The R1CS/bit costs are obtained by dividing the R1CS prover costs by the message rate. Timings are from a third-party implementation of Rescue and POSEIDON on an i9-8950 CPU $@2.9$ Ghz and 32 GB RAM.   \n\nNameS-boxRate bits/perm.SB size (log2 p)Tree arityRFRpCurve Scalar fieldR1CS /perm.R1CS /bitTime /perm.POSEIDON-80x55102552:1833BLS/BN/Ed1710.340.021 msx510202554:18352250.220.05msPOSEIDON-128x55102552:18572430.470.033msx x51020 20402554:1860 63BLS/BN/Ed3000.290.08 msPOSEIDON-2562558:184050.20.259 msx5 x51020 2040255 2552:1 4:18 8120 120BLS/BN/Ed504 6000.5 0.30.216 msPedersen Hash5162:1BLS12-3818691.680.578msRescue5102552:1162680.520.525 msx5&x1/510202554:110BLS/BN/Ed3000.290.555ms20402558:1104500.221.03 ms  \n\nOur Contributions. We design and analyze a family of hash functions over $\\mathrm{GF}(p)$ named POSEIDON. The internal permutation is called POSEIDONπ and is based on the HADES design strategy $[\\mathrm{GLR}^{+}20]$ , which is essentially a strategy based on substitution-permutation networks with t cells, but including the use of so-called partial rounds, which use nonlinear functions only for part of the state. In our specific construction, only one S-box is used in these partial rounds, while full nonlinear layers (i.e., t S-boxes) are used in all other rounds. This is done to reduce the R1CS or AET cost.  \n\nWe aim to support security levels of 80, 128, and 256 bits, where the security is the same for collision and preimage resistance. For each pair (basic field, security level) we suggest a concrete instance of POSEIDON. In our hash function, a few S-box elements are reserved for the capacity (roughly double the security level in bits), and the rest for the rate. The permutation width is determined by the application: It is set close to  \n\n1280 bits for long-message hashing, whereas for Merkle trees we support various widths to enable 2:1, 4:1, and other arities and thus higher ZK performance.  \n\nWe provide an extensive cryptanalysis of POSEIDON with an accent on algebraic methods as these prove to be the most effective. We explore different variants of interpolation, Gröbner basis, and higher-order differential attacks. As our permutations are quite wide, we do not aim for them behaving like randomly chosen permutations. Instead, for a security level of $M$ bits we require that no attack could exhibit a nonrandom (but relevant for collision/preimage search) property of a permutation faster than in $2^{M}$ queries. We then calculate the maximum number of rounds for each field, security level, and fixed permutation width that can be attacked. Then we select the number of rounds for concrete instances together with a security margin.  \n\nWe have evaluated the number of constraints in POSEIDON instances for the R1CS metric and the AET metric. Our primary proposals POSEIDON-80/128/256 are listed in Table 1 (BLS being BLS12-3811, BN being BN254 $[\\mathsf{W}^{+}14]$ , Ed being the Ristretto group2) and are compared to similar-purpose designs. Finally, we refer to Supplementary Material A for a complete overview of our auxiliary flies, including reference implementations and scripts to create POSEIDONπ instances.  \n\nWe also have third-party benchmarks of POSEIDON for regular hashing3 (Table 1) and in ZK proof systems: PLONK (Table 6), Groth16 (Table 3), and Bulletproofs (Table 5).  \n\nComparison to HADES ( $[\\mathbf{GLR}^{+}2\\mathbf{0}]_{,}$ ). Since the design of POSEIDON follows the same strategy as block ciphers in $[\\mathrm{GLR}^{+}20]$ , we provide an explicit list of new material crafted for this paper:  \n\n• Hash-function specific (CICO, keyless, preimage) algebraic attacks, their analysis, and fixes against recent hash-only attacks   \n• Orientation towards various zero-knowledge proof systems and suggestions how to increase prover performance in these systems   \n• Instances for Merkle trees and variable-length hashing   \n• Concrete benchmarks for zero-knowledge proofs of accumulated values in Merkle trees, and a demonstration that it can be done in 1 second for billion-size trees  \n\nRelated Work. The Zcash designers introduced a new 256- bit hash function called Pedersen hash [HBHW19, p.134], which is effectively a vectorized Pedersen commitment in elliptic curve groups with short vector elements. For the claimed 128-bit security level, it utilizes 869 constraints per 516-bit message chunk, thus having 1.7 constraints per bit, whereas our POSEIDON instances use from 0.2 to 0.45 constraints per bit, depending on the underlying prime field.  \n\nFor the binary field case, Ashur and Dhooghe [AD18] have recently introduced the STARK-friendly block cipher JARVIS and its derivative hash function FRIDAY with several instances and security levels. They use a key-alternating structure with a single inverse S-box, followed by an affine transformation (with low degree in the extension field). However, both JARVIS and FRIDAY were successfully attacked shortly after their publication $[\\mathrm{ACG^{+}19}]$ . In the response, the authors created a new family of SNARK/STARK-friendly hash functions with Vision (binary fields) and Rescue (prime fields) being main instances $[\\mathrm{AABS^{+}19}]$ . The latter two share some similarity with our design with two important differences: First, all S-box layers are full (there are no partial rounds). Moreover, every second layer has S-boxes of the form $x^{1/d}$ for small $d$ . This approach prevents some algebraic attacks but is also more expensive in software as the resulting power functions have high Hamming weight and thus require many squarings.  \n\nStructure of the Paper. We introduce POSEIDON as a HADES-based hash in Section 2 and follow up with real-world applications in Section 3. Concrete instances with round numbers and domain constants are given in Section 4. We summarize the cryptanalysis results in Section 5 with the details in Appendix. Finally, we estimate the performance of POSEIDON instances in zero-knowledge proof systems in Section 6 by computing R1CS (SNARK) and AET (STARK) costs.  \n\nHistoric Remarks. We started working on the design of POSEIDON in the fall of 2018. The work was triggered by the STARK paper [BBHR19] where a Rijndael-based hash function was proposed for zero-knowledge applications, but we identified that the underlying cipher is not suitable for the hash mode due to related-key trails. In the design of POSEIDON, we were inspired by the LowMC cipher $[\\mathrm{ARS^{+}15}]$ with a partial S-box layer, the block cipher SHARK with its inverse S-box and its MDS matrix as the linear layer $[\\mathrm{RDP^{+}96}]$ , and by MiMC with its algebraically simple approach of using the cube S-box $[\\mathrm{AGR}^{+}16,\\mathrm{GRR}^{+}16\\mathrm{b}]$ . We immediately considered a partial S-box layer for most of the rounds in order to gain performance and safe constraints. The S-box was initially either the inverse or a power map (as the cube function), but we later found out that the inverse function does not provide a sufficiently fast degree growth.  \n\nIn 2019, we separated the design into two parts due to diverging analysis and use cases, namely the block cipher HADESMiMC and the hash functions POSEIDON and STARKAD. The latter was designed for binary fields, as we thought that they are useful for STARKs. However, it turned out that they are neither especially useful in this setting nor equally secure [KR21, $\\mathrm{BCD}^{+}20\\mathrm{J}$ , which is why we eventually dropped STARKAD.4  \n\nAfter the first publications of the design, we got requests from third parties to add explicit Merkle tree support and encryption (to be verifiable in zero knowledge). Later we were also asked to add weaker and stronger versions. Initially we allowed for greater flexibility in the choice of Sboxes, curves, width, etc., but only a few parameter sets are now given in the main body of this paper for the matter of user convenience: It turned out that too many possible parameters confuse users. Regarding zero-knowledge proof systems, we initially targeted Groth16 [Gro16], Bulletproofs $[\\mathrm{BBB^{+}18}]$ and STARKs [BBHR19], and we later also added PLONK [GWC19] due to its increased popularity.  \n\n2 The POSEIDON Hash Function  \n\nIn the following, we propose the hash function POSEIDON, which maps strings over $\\mathbb{F}_{p}$ (for a prime $p\\!\\approx\\!2^{n}\\!>\\!2^{31}.$ ) to fixedlength strings over $\\mathbb{F}_{p}$ , i.e., POSEIDON : $\\mathbb{F}_{p}^{}\\rightarrow\\mathbb{F}_{p}^{o}$ , where $o$ is the output length measured in $\\mathbb{F}_{p}$ elements (usually, $o=1$ ). It is constructed by instantiating a sponge function with the POSEIDONπ permutation. POSEIDONπ is a variant of HADESMiMC proposed in $[\\mathrm{GLR}^{+}20]$ , albeit instantiated with a fixed and known key.  \n\nWe sometimes use the notation $p\\approx2^{n}$ and $N=n\\cdot t\\approx$ $\\log_{2}(p)\\cdot t$ to denote the approximate size of the texts in bits.  \n\n  \n\n2.1 Sponge Construction for POSEIDONπ  \n\nSponges. A sponge construction [BDPA08] builds upon an internal permutation and can be used to achieve various goals such as encryption, authentication, or hashing. In addition to the internal permutation, it is usually defined by two parameters, namely the rate (or arity in the context of tree hashing) $r$ and the capacity (or inner part) $c$ . The rate determines the throughput, whereas the capacity is crucial for the security level. This means that, when fixing the size of the internal permutation to $N$ bits, a tradeoff between throughput and security has to be made.  \n\nAn example for a sponge hash function is proposed in Fig. 1, where the construction is used to compute the hash output $h_{1}\\mid\\mid h_{2}$ of the 4-block message $m_{1}\\parallel m_{2}\\parallel m_{3}\\parallel m_{4}$ , where $m_{i}$ and $h_{i}$ are $r$ -bit values. The initial state $I$ contains all zeros, i.e., $I=0^{r}\\mid\\mid0^{c}$ for an $r$ -bit rate and a $c$ -bit capacity.  \n\nSponge Security. Depending on the properties of the $N$ -bit internal permutation, a sponge construction allows to make strong arguments about the security of the overall design. Specifically, if this permutation is modeled as a randomly chosen permutation, the sponge function is indifferentiable from a random oracle for up to $2^{c/2}$ calls ( $^{c/2}$ calls if the capacity is counted in field elements) [BDPA08]. A sponge hash function with a capacity of $c$ bits can therefore provide $2^{c/2}$ bits of collision and $2^{c/2}$ bits of (second) preimage resistance.5  \n\nIn this proposal, we instantiate the sponge function with our new permutation $\\scriptstyle\\mathrm{POSEIDON}^{\\pi}$ . Given the size $N$ of the permutation and a desired security level $s$ , we can hash $r=N-2s$ bits per call to the permutation. Following this design strategy, we choose the number of rounds of the inner permutation POSEIDONπ in order to ensure that such a permutation does not exhibit non-generic properties up to $2^{M}$ queries, where $M$ is the desired security level.6 For this we set the capacity to 2M and denote by POSEIDON- $\\mathcal{M}$ a hash function that provides $M$ bits of security against collision and preimage attacks.  \n\nOur POSEIDONπ Sponges. We provide several POSEIDON instances for different use cases, but they all use the sponge construction in the same way as illustrated in Fig. 1:  \n\n1. Depending on the use case (see Section 3 and Section 4 for more details), determine the capacity element value and the input padding if needed.   \n2. Split the obtained input into chunks of size $r$ .   \n3. Apply the permutation POSEIDONπto the capacity element and the first chunk.   \n4. Until no more chunks are left, add them into the state and apply the permutation.   \n5. Output $o$ output elements out of the rate part of the state. If needed, iterate the permutation more times.  \n\n2.2 The HADES Design Strategy for Hashing  \n\nCryptographic permutations usually consist of an efficient round function which is applied sufficiently many times in order to make the permutation behave like a randomly drawn one. In general, the same round function is used throughout the permutation, in order to destroy all of its possible symmetries and structural properties.  \n\nIn HADES we consider different round functions within the same construction. More precisely, we mix rounds with full S-box layers and rounds with partial S-box layers. The motivation to have different types of rounds is that full S-box layers are expensive in software and ZK proof systems but are a good protection against statistical attacks, whereas partial layers are relatively cheap but are, in some cases, similarly good as full ones against algebraic attacks.  \n\nDetails on the HADES Strategy. The HADES design strategy consists of $R_{f}$ rounds in the beginning, in which S-boxes are applied to the full state. After these rounds, $R_{P}$ rounds in the middle contain only a single S-box in each round, and the rest of the state goes through the nonlinear layer unchanged (i.e., identity functions are used instead of the missing Sboxes). Finally, $R_{f}$ rounds at the end are applied by again using S-boxes for the full state.  \n\nThe idea of this approach is to provide arguments for the security against statistical attacks using the $R_{F}=2R_{f}$ rounds with full S-box layers in the beginning and in the end together with the wide trail strategy [DR01], which is also used in, e.g., the AES [DR02]. On the other hand, the $R_{P}$ rounds with partial S-box layers are a more efficient way to increase the degree of the overall function, and are mainly used for arguments against algebraic attacks.  \n\nA detailed overview of this approach is shown in Fig. 2.\n\nFigure 2: Construction of the HADES-based POSEIDONπ permutation.  \n\nThe Round Function. Each round function of our POSEIDON permutation consists of the following three components.  \n\n1. AddRoundConstants, denoted by $A R C(\\cdot)$   \n2. SubWords, denoted by $\\operatorname{S-box}(\\cdot)$ or by $S B(\\cdot)$   \n3. MixLayer, denoted by $M(\\cdot)$  \n\nThe MixLayer operation is the linear layer of our construction, and it consists in multiplying the state with a $t\\times t$ MDS matrix in order to apply the wide trail strategy.  \n\n2.3 The Permutation Family POSEIDONπ  \n\nThe HADES design strategy provides a good starting point for our new hash function. Indeed, the combination of full and partial rounds allows us to make strong arguments about the security, while also exploiting the smaller number of S-boxes in the partial rounds in order to gain efficiency in the target applications.  \n\nThe primary application of our design is hashing in large prime fields, hence POSEIDONπ takes inputs of $t\\geq2$ words in $\\mathbb{F}_{p}$ , where $p$ is a prime of size $p\\approx2^{n}>2^{30}$ (i.e., $\\lceil\\log_{2}(p)\\rceil=$ $n\\geq31$ ). We will now describe the components of each POSEIDONπ round in detail.  \n\nThe S-Box Layer. For the applications we have in mind, we focus on the $\\upalpha$ -power S-box, defined by $\\mathbf{S}{-}\\mathsf{b o x}(x)=x^{\\alpha}$ , where $\\upalpha\\geq3$ is the smallest positive integer that satisfies $\\operatorname{gcd}(\\alpha,p-1)=1$ . In the following, these permutations are called $\\begin{array}{r}{\\mathbf{\\dot{\\omega}}_{\\mathcal{X}}\\mathbf{\\alpha}_{-\\mathrm{POSEIDON}}\\pi,:}\\end{array}$ . Examples are given by $\\mathbf{a}=3$ $x^{3}$ -POSEIDONπ) if $p\\neq1$ mod 3, or $\\upalpha=5$ ( $x^{5}$ -POSEIDONπ) if $p=1\\mod3$ and $p\\neq1$ mod 5.  \n\nIt turns out that the S-box $x^{5}$ is suitable for two of the most popular prime fields in ZK applications, concretely the prime subfields of the scalar field of the BLS12-381 and BN254 curves, so we mainly consider this S-box, but try to present generic cryptanalytic results for other cases whenever possible.  \n\nIn total we get:  \n\n$$\n\\underbrace{A R C\\rightarrow S B\\rightarrow M}_{\\mathrm{First\\,round}}\\rightarrow\\dots\\rightarrow\\underbrace{A R C\\rightarrow S B\\rightarrow M}_{(R-1)\\cdot\\mathrm{th\\,round}}\\rightarrow\\underbrace{A R C\\rightarrow S B\\rightarrow M}_{R\\cdot\\mathrm{th\\,round}}\n$$  \n\nWhile $A R C(\\cdot)$ and $M(\\cdot)$ are the same in each round, the number of S-boxes is not the same, namely  \n\n• $R_{f}\\!+\\!R_{f}=\\!R_{F}$ rounds have full S-box layers, i.e., $t$ S-box functions, and   \n• $R_{P}$ rounds have partial S-box layers, i.e., 1 S-box and $\\left(t-1\\right)$ identity functions.  \n\nWe refer to $[\\mathrm{GLR}^{+}20]$ for more details about the HADES design strategy.  \n\nInteraction Between Full and Partial Rounds. Note that the same number of full rounds can be used instead of the partial rounds without decreasing the security, but this leads to substantially higher costs in our target applications. However, replacing $t$ partial rounds with one full round may keep the costs in our target applications similar, but the security may be severely decreased due to a significantly lower degree of 1 full round compared to $t$ partial rounds.  \n\nThe Linear Layer. A $t\\times t$ MDS matrix with elements in $\\mathbb{F}_{p}$ exists if $2t+1\\leq p$ (see [MS78] for details).7  \n\nGiven $p$ and $t$ , there are several ways to construct an MDS matrix. One of them is using a Cauchy matrix [YMT97], which we recall here briefly. For $x_{i},y_{i}\\in\\mathbb{F}_{p}$ , where $i\\in[1,t]$ , the entries of the matrix $\\mathcal{M}$ are defined by  \n\n$$\n\\mathcal{M}_{i,j}=\\frac{1}{x_{i}+y_{j}},\n$$  \n\nwhere the entries of $\\{x_{i}\\}_{1\\leq i\\leq t}$ and $\\{y_{i}\\}_{1\\leq i\\leq t}$ are pairwise distinct and $x_{i}+y_{j}\\neq0$ , where $i\\in\\{1,\\ldots,t\\}$ and $j\\in\\{1,\\ldots,t\\}$ .  \n\nAvoiding Insecure Matrices. We emphasize that not every MDS matrix provides the same level of security. In particular, the matrix $\\mathcal{M}$ must prevent the possibility to set up  \n\n(1) invariant (or iterative) subspace trails [GRR16a] (or equivalently, truncated differentials) with prob. 1 with inactive S-boxes over more than $t-1$ rounds8 (more details are given in the following), or  \n\n(2) invariant (or iterative) subspace trails with prob. 1 and with active S-boxes for any number of rounds.  \n\nRegarding the first point, let $S^{i}$ be the subspace s.t. no S-box is active in the first $i$ consecutive rounds, that is,  \n\n$$\n{\\mathcal{S}}^{(i)}:=\\left\\{\\,\\nu\\in\\mathbb{F}^{t}\\;\\big\\vert\\;[{\\mathcal{M}}^{j}\\cdot\\nu]_{0}=0\\in\\mathbb{F},j<i\\,\\right\\},\n$$  \n\nwhere $[x]_{0}$ denotes the first word of $x\\in\\mathbb{F}^{t}$ , $S^{(0)}=\\mathbb{F}^{t}$ , and $\\dim\\left(S^{(i)}\\right)\\geq t-i.$ . For each pair of texts $(x,y)$ in the same coset of $S^{i}$ , no S-boxes are active in the first $i$ consecutive rounds. Hence, a truncated differential with prob. 1 (or equivalently, a subspace trail) can be set up for the first $i\\leq t-1$ rounds. The matrix $\\mathcal{M}$ must be chosen s.t. no subspace trail with inactive/active S-boxes can be set up for more than $t-1$ rounds.  \n\nA detailed analysis of matrix properties related to this attack vector can be found in [GRS21]. With these results in mind, we suggest the following method to generate matrices:  \n\n1. Randomly select pairwise distinct $\\{x_{i}\\}_{1\\leq i\\leq t}$ and $\\{y_{i}\\}_{1\\leq i\\leq t}$ , where $x_{i}+y_{j}\\neq0$ and where $i\\in\\{1,\\dotsc,t\\}$ and $j\\in\\{1,\\ldots,t\\}$ .  \n\n2. Determine if the matrix is secure using Algorithm 1, Algorithm 2, and Algorithm 3 provided9 in [GRS21]. For a secure matrix, no infinitely long (invariant and/or iterative) subspace trail (with or without active S-boxes) can be set up for all rounds with partial S-box layers.  \n\n3. Repeat this procedure until a secure matrix is found.  \n\nWe used this method to generate the matrices for the instantiations given in Section 4. For [GRS21, Algorithm 3], we used a search period of $l=4t$ , and we additionally made sure that no invariant subspace trails with active S-boxes exist for $M,M^{2},\\dots,M^{l}$ . In our experiments, we observed that only a few trials are needed in order to find a secure matrix for sufficiently large fields.  \n\nTo summarize, this approach allows us to make sure that our MDS matrices do not exhibit the vulnerabilities discussed in [GRS21], and our instantiations are thus secure against this specific type of attack.  \n\nEfficient Implementation. We refer to Supplementary Material B for details about efficient POSEIDONπimplementations. The main advantage of these strategies consists of reducing the number of constant multiplications in each round with a partial S-box layer from $t^{2}$ to $2t$ , which is particularly useful for large $t$ and $R_{P}$ . For example, we implemented $x^{3}{\\mathrm{-}}\\mathrm{POSEIDON}^{\\pi}$ with $(n,t,R_{F},R_{P})=(64,24,8,42)$ in Sage, and we could observe that the performance improves by a factor of about 5, with the average computation time being 4 ms for the optimized version.  \n\n3 Applications  \n\nWe suggest POSEIDON for all applications of zero-knowledgefriendly hashing, concretely:  \n\n• Using POSEIDON for commitments in various protocols, where the knowledge of the committed value is proven in zero knowledge: For this we suggest a singlecall permutation-based hashing with POSEIDON-128 and widths from 2 to 5 field elements. The advantage over the Pedersen hash, for example, is that POSEIDON is faster and can also be used in signature schemes which allows for a smaller code footprint. • Hashing multi-element objects with certain fields encoded as field elements, so that statements about these fields are proven in zero knowledge: We suggest variablelength sponge-based hashing with POSEIDON-128 or POSEIDON-80 with width 5 (and rate 4). • Using POSEIDON in Merkle trees to enable zeroknowledge proofs of knowledge of a leaf in the tree with optional statements about the leaf content: We recommend Merkle trees of arity 4 (i.e., width 5) with POSEIDON-128 as the most performant, but trees of more conventional arities can be used as well. • Verifiable encryption with POSEIDON within Integrated Encryption Scheme [GMHESÁ10]: Put POSEIDON inside the DuplexSponge authenticated encryption framework [BDPA11] and initialize it with a session key based on the recipient’s public key. Then one can prove that the recipient can decrypt the ciphertext into a plaintext with certain properties.  \n\nThere exist several third-party protocols that already use POSEIDON in these use cases:  \n\n• Filecoin employs POSEIDON for Merkle tree proofs with different arities and for two-value commitments.10 • Dusk Network uses POSEIDON to build a Zcash-like protocol for securities trading.11 It also uses POSEIDON for encryption as described above.  \n\n• Sovrin uses POSEIDON for Merkle-tree based revocation [Lod19].   \n• Loopring uses POSEIDON for private trading on Ethereum.12  \n\n4 Concrete Instantiations of POSEIDONπ  \n\nAs of mid-2020, many protocols that employ zero-knowledge proofs use (or plan to use) pairing-based proof systems [PHGR13, Gro16, GWC19, $\\mathrm{CHM}^{+}20]$ or Bulletproofs $[\\mathrm{BBB^{+}18}]$ . The elliptic curves used by these systems are predominantly BLS12-381, BN254, and Ed25519. A hash function friendly for such a system would operate in the scalar prime field of the curve, and they all have a size of around 2255.  \n\n4.1 Main Instances  \n\nWe present POSEIDONπ permutations for such prime fields, and leave the other cases to the appendix. The S-box function can be chosen as $x^{5}$ in all cases, i.e., we use $x^{5}$ -POSEIDON for hashing in all such protocols, though the concrete fields are slightly different (this affects only constants and matrices, but not the number of rounds).  \n\nThe security levels $M$ of 80 and 128 bits correspond to a 255-bit capacity, i.e., one field element. We focus on two possible widths, namely $t=3$ and $t=5$ , as they correspond to popular cases of 2-to-1 and 4-to-1 compression functions. In the Merkle tree case, this corresponds to trees of arity 2 and 4, respectively. The round numbers for 80- and 128-bit security levels are given in Table 2, and a more extensive set is given in the appendix. For $M=256$ we select a capacity and an output of 2 255-bit elements (one 510-bit element is possible too).  \n\nAll our MDS matrices are Cauchy matrices, and the method to construct them is further described in Section 2.3. We use sequences of integers for the construction.  \n\nThe round constants and matrices are generated using the Grain LFSR [HJMM08] in a self-shrinking mode, and the detailed initialization and generation are described in Supplementary Material E. Using this method, the generation of round constants and matrices depends on the specific instance, and thus different round constants are used even if some of the chosen parameters (e.g., $n$ and $t$ ) are the same. Note that by using the Grain LFSR and instance-specific seed values, this approach is reminiscent of nothing-up-my-sleeve (NUMS) numbers. Indeed, letting the attacker freely choose round constants and/or matrices can lead to attacks.  \n\nTable 2: Concrete instantiations of POSEIDONπ (with security margin) over BLS12-381, BN254, Ed25519 scalar fields.   \n\nInstance (S-box: f(x) = x) | tRFRpPOSEIDON\"-1283 58 857 60POSEIDON\"-803 58 833 35POSEIDON\"-2566 108 8120 120  \n\nWe provide the round constants, the matrices, and test vectors in auxiliary flies for four primary instantiations. We also make reference implementations for these instantiations and scripts to calculate the round numbers, the round constants, and the MDS matrices available online.13 We refer to Supplementary Material A for a more detailed overview of the auxiliary flies.  \n\n4.2 Domain Separation for POSEIDON  \n\nPOSEIDON can be used in a number of applications, and having the same instance for all of them is suboptimal. Also, some protocols explicitly require several different hash functions. We suggest using domain separation for this, concretely encoding the use case in the capacity element (which is fine as it is 256 bits large and has a lot of bits to fill) and using some padding to distiguish inputs of different lengths if they may happen. Although a concrete form of domain separation constants is not security critical, we suggest a common methodology to unify potential implementations.  \n\nConcretely, we propose:  \n\n• Merkle Tree (all leafs are present, up to arity 32). The capacity is $2^{a r i t y}-1$ . A generic case is considered in Supplementary Material H. We use no padding here.   \n• Merkle Tree (some leafs may be empty). The capacity value equals the bitmask of which leafs are present. We use no padding here.   \n• Variable-Input-Length Hashing. The capacity value is $2^{64}+(o-1)$ where $o$ the output length. The padding consists of one field element being 1, and the remaining elements being 0.   \n• Constant-Input-Length Hashing. The capacity value is length $\\cdot\\left(2^{64}\\right)+\\left(o-1\\right)$ where $o$ the output length. The padding consists of the field elements being 0.   \n• Encryption. The capacity value is $2^{32}$ . The padding consists of the field elements being 0.  \n\n• Future Uses. The capacity value is identifier· $\\left(2^{32}\\right)$ . The padding depends on the application.  \n\n5 Cryptanalysis Summary of POSEIDON  \n\nAs for any new design, it is paramount to present a concrete security analysis. In the following, we provide an in-depth analysis of the security of our construction. Due to a lack of any method to ensure that a hash function based on a sponge construction is secure against all possible attacks, we base our argumentation on the following consideration. As we just recalled in the previous section, when the internal permutation $\\mathcal{P}$ of an $(N=c+r)$ -bit sponge function is modeled as a randomly chosen permutation, the sponge hash function is indifferentiable from a random oracle up to $2^{c/2}$ calls to $\\mathcal{P}$ . Thus, we choose the number of rounds of the inner permutation case in order to provide security against distinguishers relevant to collision/preimage attacks. Equivalently, this means that such a number of rounds guarantees that $\\mathcal{P}$ does not exhibit any relevant non-random/structural properties (among the ones known in the literature).  \n\n5.1 Definitions  \n\nDefinition 5.1. The function $F$ is $T$ -secure against collisions if there is no algorithm with expected complexity smaller than $T$ that finds $x_{1},x_{2}$ such that $F\\!\\left(x_{1}\\right)=F\\!\\left(x_{2}\\right)$ .  \n\nDefinition 5.2. The function $F$ is $T$ -secure against preimages if there is no algorithm with expected complexity smaller than $T$ that for given $y$ finds $x$ such that $\\boldsymbol{F}(\\boldsymbol{x})=\\boldsymbol{y}$ .  \n\nDefinition 5.3. The function $F$ is $T$ -secure against second preimages if there is no algorithm with expected complexity smaller than $T$ that for given $x_{1}$ finds $x_{2}$ such that $F(x_{1})=$ $F\\!\\left(x_{2}\\right)$ .  \n\nDefinition 5.4. The invertible function $P$ is $T$ -secure against the CICO $(m_{1},m_{2})$ -problem if there is no algorithm with expected complexity smaller than $T$ that for given $m_{1}$ -bit $I_{1}$ and $m_{2}$ -bit $O_{1}$ finds $I_{2},O_{2}$ such that $P(I_{1}O_{2})$ .  \n\n5.2 Security Claims  \n\nIn terms of concrete security, we claim that POSEIDON-M is $2^{M}$ -secure against collisions and (second) preimages. To help increase confidence in our design and simplify external cryptanalysis, we also explicitly state another claim about our internal permutation: POSEIDONπ is $2^{\\mathrm{min}(M,m_{1},m_{2})}$ -secure against the CICO $(m_{1},m_{2})$ -problem.  \n\nEven though an attack below these thresholds may not affect any concrete applications of our hash functions, we would still consider it an important cryptanalytic result.  \n\n5.3 Summary of Attacks  \n\nHere we list the main points of our cryptanalysis results. The number of rounds $R=R_{P}+R_{F}$ we can break depends on the security level $M$ and the number of S-boxes $t$ , which we specify for each concrete hash function instance in the next section.  \n\nBefore going on, we point out that for all attacks that are in common to the ones proposed for the cipher HadesMiMC $[\\mathrm{GLR}^{+}20]$ , here we limit ourselves to report the main idea and result. For all other cases (namely, higher-order differentials, zero-sum partitions, Gröbner basis attacks, and preimage attacks), we present here more details. In any case, all details are provided as supplementary material.  \n\nWe highlight that the following cryptanalysis is not equivalent to the one presented for the block cipher HADESMiMC. Indeed, the scenarios are different (in one case the goal is to guarantee the impossibility to find the secret key, while here there is no secret key material and the goal is to guarantee that the internal permutation looks like a pseudo-random permutation). This means that certain attacks that we consider here are not valid in the case of a block cipher and vice-versa. Just to give some examples, the rebound attack $[\\mathrm{LMR}^{+}09$ ,MRST09] holds only in the context studied here, while a MitM scenario (crucial in the case of an SPN cipher) does not work in the context of a sponge function, since the attacker does not know the full output. More details are given in the following.  \n\nProposition 5.1 (Informal). The following number of rounds for $x^{5}$ -POSEIDON-128 over $\\mathbb{F}_{p}$ with $\\approx256$ -bit $p$ protects against statistical and algebraic attacks:  \n\n$$\nR_{F}=6,\\qquad R=R_{F}+R_{P}=56+\\lceil\\log_{5}(t)\\rceil.\n$$  \n\nProof. We substitute $\\alpha=5,M=128$ and $\\log_{2}(p)=255$ to Equations (2),(3),(4) and see that no one is satisfied, i.e., the attacks do not work. 口  \n\nProposition 5.2 (Informal). The following number of rounds for $x^{5}$ -POSEIDON-80 over $\\mathbb{F}_{p}$ with $\\approx\\,256\\cdot$ -bit $p$ protects against statistical and algebraic attacks:  \n\n$$\nR_{F}=6,\\qquad R=R_{F}+R_{P}=35+\\lceil\\log_{5}(t)\\rceil.\n$$  \n\nProposition 5.3 (Informal). The following number of rounds for $x^{5}$ -POSEIDON-256 over $\\mathbb{F}_{p}$ with $\\approx\\,256\\cdot$ -bit $p$ protects against statistical and algebraic attacks:  \n\n$$\nR_{F}=6,\\qquad R=R_{F}+R_{P}=111+\\lceil\\log_{5}(t)\\rceil.\n$$  \n\n5.4 Security Margin  \n\nGiven the minimum number of rounds necessary to provide security against all attacks known in the literature, we arbitrarily decided to add  \n\n$(I)$ two more rounds with full S-box layers, and  \n\n(2) $7.5\\%$ more rounds with partial S-box layers,  \n\ni.e., $+2\\,R_{F}$ and $+7.5\\%R_{P}$ . The resulting number of rounds for our primary instances is given in Table 2.  \n\n5.5 Attack details  \n\nAll the attacks below are applied to the internal permutation POSEIDONπ. The sponge framework dictates that all the attacks on the hash function with complexity below $2^{c/2}$ must result from attacks on the permutation. Thus we show that no such attack on the permutation should exist.  \n\n5.5.1 Statistical Attacks  \n\nDifferential/Linear Distinguishers. As shown in the appendix, at least 6 rounds with full S-box layers are necessary to provide security against the statistical attacks we consider. In more detail, for  \n\n$$\nR_{F}<{\\left\\{\\begin{array}{l l}{6\\qquad{\\mathrm{if}}\\ M\\leq(\\left\\lfloor\\log_{2}p\\right\\rfloor-C)\\cdot(t+1)}\\\\ {10\\qquad{\\mathrm{otherwise}}}\\end{array}\\right.}\n$$  \n\nlinear [Mat93] and differential [BS91, BS93] attacks may be possible, where $C=\\log_{2}(\\alpha-1)$ for $S(x)=x^{\\alpha}$ (where remember that $\\upalpha$ is an odd integer number), e.g., $C=1$ for $S(x)=x^{3}$ and $C=2$ for $S(x)=x^{5}$ .  \n\nBefore going on, we highlight that we exploit only rounds with full S-box layers in order to prevent statistical attacks (as done in $[\\mathrm{GLR}^{+}20]$ ). As explained in [KR21], under the assumption made for the linear layer in Section 2.3, it is possible to exploit both the rounds with partial and full S-box layers in order to guarantee security against some statistical attacks, like differential and linear attacks. Our decision to consider only rounds with full S-box layers has been made since a similar condition on the rounds with full S-box layers (e.g., $R_{F}\\geq6)$ ) is necessary for the security against some algebraic attacks (e.g., Gröbner basis attacks – see in the following) and in order to provide simple security arguments for all statistical attacks (including e.g. the rebound one).  \n\n(Invariant) Subspace Trails. We emphasize that the choice of the matrix that defines the linear layer, made in Section 2.3, prevents the existence of subspaces $\\mathcal{S}$ that generate infinitely long subspace trails, namely a finite collection of subspaces $\\{S_{0},\\ldots,S_{r-1}\\}$ s.t. each coset of ${\\mathcal{S}}_{i}$ is mapped into a coset of $S_{i+1}$ with probability 1 (where the index is taken modulo $r$ ) an arbitrary number of times. This allows to fix the weakness of the previous version of POSEIDON.  \n\nOther Attacks. Finally, we briefly mention that the same number of rounds given before for the case of differential/linear attacks guarantees security against other attacks as truncated differentials [Knu94], impossible differentials [BBS99], rebound attacks $[\\mathrm{LMR}^{+}09$ ,MRST09], and so on. More details are given in the appendix.  \n\n5.5.2 Algebraic Attacks  \n\nIn order to estimate the security against algebraic attacks, we evaluate the degree of the reduced-round permutations and their inverses. Roughly speaking, our results can be summarized as follows, where $n\\simeq\\log_{2}(p)$ .  \n\nInterpolation Attack. The interpolation attack [JK97] depends on the number of different monomials in the interpolation polynomial, where (an upper/lower bound of) the number of different monomials can be estimated given the degree of the function. The idea of such an attack is to construct an interpolation polynomial that describes the function. If the number of unknown monomials is sufficiently large, then this cannot be done faster than via a brute-force attack.  \n\nFor a security level of $M$ bits, the number of rounds that can be attacked is  \n\n$$\nR\\leq\\left\\lceil\\log_{\\alpha}(2)\\cdot\\operatorname{min}\\{M,\\log_{2}(p)\\}\\right\\rceil+\\left\\lceil\\log_{\\alpha}t\\right\\rceil.\n$$  \n\nIn general, the number of unknown monomials does not decrease when increasing the number of rounds. Hence, a higher number of rounds likely leads to a higher (or equal) security against this attack. We also consider various approaches of the attack (such as the MitM one) in Supplementary Material C.2.1.  \n\nGröbner Basis Attack. In a Gröbner basis attack [CLO97], one tries to solve a system of nonlinear equations that describe the function. The cost of such an attack depends on the degree of the equations, but also on the number of equations and on the number of variables. Since there are several ways for describing the studied permutation, there are several ways to set up such a system of equations and so the attack. Here, we focus on two extreme cases:  \n\n1. In the first case, the attacker derives equations, one for each word, for the entire $r$ -round permutation. Assuming $S(x)=x^{\\alpha}$ (analogous for the others), we show that the attack complexity is about $\\alpha^{2t}$ (see below), therefore for a security level of $M$ bits the attack works at most on $\\log_{\\alpha}2^{\\operatorname{min}\\left\\{n/2,M/2\\right\\}}$ rounds.   \n2. In the second case, since a partial S-box layer is used, it may be more efficient to consider degree- $\\upalpha$ equations", "files_in_pdf": [{"path": ".pdf_temp/viewrange_chunk_1_1_5_1761834455/images/f8s2zg.jpg", "size": 24179}, {"path": ".pdf_temp/viewrange_chunk_1_1_5_1761834455/images/l00ezz.jpg", "size": 168588}, {"path": ".pdf_temp/viewrange_chunk_2_6_10_1761834462/images/v03rk3.jpg", "size": 44193}, {"path": ".pdf_temp/viewrange_chunk_2_6_10_1761834462/images/mzgh4a.jpg", "size": 36556}]}